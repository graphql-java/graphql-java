#
# This resource bundle is used for the query validation code to produce i18n messages
#
# The keys have the format of rule class name and then message type within that.  Most rules
# will only have 1 or 2 message keys
#
# Please try and keep this sorted within rule class and use # between sections so the IDEA Ctrl-Alt-L reformat does not bunch
# them too tightly.
#
# REMEMBER - a single quote ' in MessageFormat means things that are never replaced within them
# so use 2 '' characters to make it one ' on output.  This will take for the form ''{0}''
#

DeferDirective.notAllowedOperationRootLevelMutation=Validation error ({0}) : Defer directive cannot be used on root mutation type ''{1}''
DeferDirective.notAllowedOperationRootLevelSubscription=Validation error ({0}) : Defer directive cannot be used on root subscription type ''{1}''
DeferDirective.labelMustBeStaticString= Validation error ({0}) : Defer directive?s label argument must be a static string
IncrementalDirective.notAllowedSubscriptionOperation=Validation error ({0}) : Directive ''{1}'' is not allowed to be used on operation subscription

IncrementalDirective.uniqueArgument=Validation error ({0}) : There can be only one argument named ''{1}'' for directive defer/Stream 
#
ExecutableDefinitions.notExecutableType=Validation error ({0}) : Type ''{1}'' definition is not executable
ExecutableDefinitions.notExecutableSchema=Validation error ({0}) : Schema definition is not executable
ExecutableDefinitions.notExecutableDirective=Validation error ({0}) : Directive ''{1}'' definition is not executable
ExecutableDefinitions.notExecutableDefinition=Validation error ({0}) : Provided definition is not executable
#
FieldsOnCorrectType.unknownField=Validation error ({0}) : Field ''{1}'' in type ''{2}'' is undefined
#
FragmentsOnCompositeType.invalidInlineTypeCondition=Validation error ({0}) : Inline fragment type condition is invalid, must be on Object/Interface/Union
FragmentsOnCompositeType.invalidFragmentTypeCondition=Validation error ({0}) : Fragment type condition is invalid, must be on Object/Interface/Union
#
KnownArgumentNames.unknownDirectiveArg=Validation error ({0}) : Unknown directive argument ''{1}''
KnownArgumentNames.unknownFieldArg=Validation error ({0}) : Unknown field argument ''{1}''
#
KnownDirectives.unknownDirective=Validation error ({0}) : Unknown directive ''{1}''
KnownDirectives.directiveNotAllowed=Validation error ({0}) : Directive ''{1}'' not allowed here
#
KnownFragmentNames.undefinedFragment=Validation error ({0}) : Undefined fragment ''{1}''
#
KnownTypeNames.unknownType=Validation error ({0}) : Unknown type ''{1}''
#
KnownOperationTypes.noOperation=Validation error ({0}): The ''{1}'' operation is not supported by the schema
#
LoneAnonymousOperation.withOthers=Validation error ({0}) : Anonymous operation with other operations
LoneAnonymousOperation.namedOperation=Validation error ({0}) : Operation ''{1}'' is following anonymous operation
#
NoFragmentCycles.cyclesNotAllowed=Validation error ({0}) : Fragment cycles not allowed
#
NoUndefinedVariables.undefinedVariable=Validation error ({0}) : Undefined variable ''{1}''
#
NoUnusedFragments.unusedFragments=Validation error ({0}) : Unused fragment ''{1}''
#
NoUnusedVariables.unusedVariable=Validation error ({0}) : Unused variable ''{1}''
#
OverlappingFieldsCanBeMerged.differentFields=Validation error ({0}) : ''{1}'' : ''{2}'' and ''{3}'' are different fields
OverlappingFieldsCanBeMerged.differentArgs=Validation error ({0}) : ''{1}'' : fields have different arguments
OverlappingFieldsCanBeMerged.differentNullability=Validation error ({0}) : ''{1}'' : fields have different nullability shapes
OverlappingFieldsCanBeMerged.differentLists=Validation error ({0}) : ''{1}'' : fields have different list shapes
OverlappingFieldsCanBeMerged.differentReturnTypes=Validation error ({0}) : ''{1}'' : returns different types ''{2}'' and ''{3}''
#
PossibleFragmentSpreads.inlineIncompatibleTypes=Validation error ({0}) : Fragment cannot be spread here as objects of type ''{1}'' can never be of type ''{2}''
PossibleFragmentSpreads.fragmentIncompatibleTypes=Validation error ({0}) : Fragment ''{1}'' cannot be spread here as objects of type ''{2}'' can never be of type ''{3}''
#
ProvidedNonNullArguments.missingFieldArg=Validation error ({0}) : Missing field argument ''{1}''
ProvidedNonNullArguments.missingDirectiveArg=Validation error ({0}) : Missing directive argument ''{1}''
ProvidedNonNullArguments.nullValue=Validation error ({0}) : Null value for non-null field argument ''{1}''
#
ScalarLeaves.subselectionOnLeaf=Validation error ({0}) : Subselection not allowed on leaf type ''{1}'' of field ''{2}''
ScalarLeaves.subselectionRequired=Validation error ({0}) : Subselection required for type ''{1}'' of field ''{2}''
#
SubscriptionUniqueRootField.multipleRootFields=Validation error ({0}) : Subscription operation ''{1}'' must have exactly one root field
SubscriptionUniqueRootField.multipleRootFieldsWithFragment=Validation error ({0}) : Subscription operation ''{1}'' must have exactly one root field with fragments
SubscriptionIntrospectionRootField.introspectionRootField=Validation error ({0}) : Subscription operation ''{1}'' root field ''{2}'' cannot be an introspection field
SubscriptionIntrospectionRootField.introspectionRootFieldWithFragment=Validation error ({0}) : Subscription operation ''{1}'' fragment root field ''{2}'' cannot be an introspection field
#
UniqueArgumentNames.uniqueArgument=Validation error ({0}) : There can be only one argument named ''{1}''
#
UniqueDirectiveNamesPerLocation.uniqueDirectives=Validation error ({0}) : Non repeatable directives must be uniquely named within a location. The directive ''{1}'' used on a ''{2}'' is not unique
#
UniqueFragmentNames.oneFragment=Validation error ({0}) : There can be only one fragment named ''{1}''
#
UniqueOperationNames.oneOperation=Validation error ({0}) : There can be only one operation named ''{1}''
#
UniqueVariableNames.oneVariable=Validation error ({0}) : There can be only one variable named ''{1}''
#
VariableDefaultValuesOfCorrectType.badDefault=Validation error ({0}) : Bad default value ''{1}'' for type ''{2}''
#
VariablesAreInputTypes.wrongType=Validation error ({0}) : Input variable ''{1}'' type ''{2}'' is not an input type
#
VariableTypesMatchRule.unexpectedType=Validation error ({0}) : Variable ''{1}'' of type ''{2}'' used in position expecting type ''{3}''
#
UniqueObjectFieldName.duplicateFieldName=Validation Error ({0}) : There can be only one field named ''{1}''
#
# These are used but IDEA cant find them easily as being called
#
# suppress inspection "UnusedProperty"
ArgumentValidationUtil.handleNullError=Validation error ({0}) : argument ''{1}'' with value ''{2}'' must not be null
# suppress inspection "UnusedProperty"
ArgumentValidationUtil.handleScalarError=Validation error ({0}) : argument ''{1}'' with value ''{2}'' is not a valid ''{3}''
# suppress inspection "UnusedProperty"
ArgumentValidationUtil.handleScalarErrorCustomMessage=Validation error ({0}) : argument ''{1}'' with value ''{2}'' is not a valid ''{3}'' - {4}
# suppress inspection "UnusedProperty"
ArgumentValidationUtil.handleEnumError=Validation error ({0}) : argument ''{1}'' with value ''{2}'' is not a valid ''{3}''
# suppress inspection "UnusedProperty"
ArgumentValidationUtil.handleEnumErrorCustomMessage=Validation error ({0}) : argument ''{1}'' with value ''{2}'' is not a valid ''{3}'' - {4}
# suppress inspection "UnusedProperty"
ArgumentValidationUtil.handleNotObjectError=Validation error ({0}) : argument ''{1}'' with value ''{2}'' must be an object type
# suppress inspection "UnusedProperty"
ArgumentValidationUtil.handleMissingFieldsError=Validation error ({0}) : argument ''{1}'' with value ''{2}'' is missing required fields ''{3}''
# suppress inspection "UnusedProperty"
ArgumentValidationUtil.handleExtraFieldError=Validation error ({0}) : argument ''{1}'' with value ''{2}'' contains a field not in ''{3}'': ''{4}''
# suppress inspection "UnusedProperty"
# suppress inspection "UnusedMessageFormatParameter"
ArgumentValidationUtil.extraOneOfFieldsError=Validation error ({0}) : Exactly one key must be specified for OneOf type ''{3}''.
#
MaxQueryDepthExceeded.message=Query depth {1} exceeds maximum allowed depth {0}
MaxQueryFieldsExceeded.message=Query has {1} fields which exceeds maximum allowed {0}