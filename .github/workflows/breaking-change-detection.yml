name: Breaking API Change Detection
# Detects breaking changes in @PublicApi annotated classes and labels PRs accordingly.
# Uses git diff to find removed public members â€” no extra tooling required.
on:
  pull_request:
    branches:
      - master
      - 23.x
      - 22.x
      - 21.x
      - 20.x
      - 19.x
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  detect-breaking-changes:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Detect breaking API changes in @PublicApi classes
        id: detect
        env:
          BASE_REF: ${{ github.base_ref }}
        run: |
          git fetch origin "$BASE_REF" --no-tags

          python3 - << 'PYEOF'
          import subprocess, re, os, sys

          base_ref = os.environ['BASE_REF']

          # Files that were modified or deleted relative to the base branch.
          # Deleted files cover entire @PublicApi class removals; modified files
          # cover removed/changed members within an existing class.
          result = subprocess.run(
              ['git', 'diff', f'origin/{base_ref}...HEAD',
               '--name-only', '--diff-filter=MD', '--', '*.java'],
              capture_output=True, text=True, check=True,
          )
          changed_files = [f for f in result.stdout.splitlines() if f.endswith('.java')]

          # Matches a removed line that declares a public member (method, field,
          # constructor).  We exclude class/interface/enum declarations because
          # those are caught by whole-file deletion, and annotations (@) because
          # they are not callable members.
          PUBLIC_MEMBER_RE = re.compile(
              r'^\s*public\s+'
              r'(?!class\b|interface\b|enum\b|@interface\b)',
          )
          COMMENT_RE = re.compile(r'^\s*(?://|/?\*)')

          breaking = {}  # filepath -> [removed signatures]

          for filepath in changed_files:
              diff = subprocess.run(
                  ['git', 'diff', f'origin/{base_ref}...HEAD', '--', filepath],
                  capture_output=True, text=True,
              ).stdout

              removed_lines = [
                  l[1:] for l in diff.splitlines()
                  if l.startswith('-') and not l.startswith('---')
              ]

              # Is this a @PublicApi type?  Check the current version on disk
              # (for modified files) or the removed content (for deleted files).
              is_public_api = False
              try:
                  with open(filepath) as f:
                      is_public_api = '@PublicApi' in f.read()
              except FileNotFoundError:
                  pass
              if not is_public_api:
                  is_public_api = any('@PublicApi' in l for l in removed_lines)

              if not is_public_api:
                  continue

              # Collect removed public member signatures from the diff.
              for line in removed_lines:
                  stripped = line.strip()
                  if not stripped or COMMENT_RE.match(stripped) or stripped.startswith('@'):
                      continue
                  if PUBLIC_MEMBER_RE.match(line):
                      breaking.setdefault(filepath, []).append(stripped)

          if breaking:
              print('Breaking API changes found in @PublicApi classes:')
              lines = []
              for filepath, sigs in breaking.items():
                  for sig in sigs:
                      entry = f'{filepath}: {sig}'
                      print(f'  {entry}')
                      lines.append(entry)
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  summary = '\n'.join(lines)
                  f.write('has_breaking_changes=true\n')
                  f.write(f'summary<<SUMMARY_EOF\n{summary}\nSUMMARY_EOF\n')
          else:
              print('No breaking API changes detected in @PublicApi classes.')
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write('has_breaking_changes=false\n')
                  f.write('summary=\n')
          PYEOF

      - name: Add 'breaking change' label to PR
        if: steps.detect.outputs.has_breaking_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['breaking change'],
            });

      - name: Remove 'breaking change' label if no longer applicable
        if: steps.detect.outputs.has_breaking_changes == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'breaking change',
              });
            } catch (e) {
              if (e.status !== 404) throw e;
            }

      - name: Post breaking-changes summary comment on PR
        if: steps.detect.outputs.has_breaking_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const summary = `${{ steps.detect.outputs.summary }}`;
            const commentMarker = '<!-- breaking-api-change-bot -->';

            const body = `${commentMarker}
            ## Breaking API Changes Detected

            This PR removes or changes public members of \`@PublicApi\` annotated classes.
            It has been automatically labeled as **breaking change**.

            <details>
            <summary>Affected signatures</summary>

            \`\`\`
            ${summary}
            \`\`\`

            </details>`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.find(c => c.body.includes(commentMarker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }
