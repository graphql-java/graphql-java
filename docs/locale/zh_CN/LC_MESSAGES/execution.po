# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Brad Baker
# This file is distributed under the same license as the graphql-java
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr "Project-Id-Version: graphql-java current\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-11 19:21+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../../execution.rst:2
msgid "Execution"
msgstr "执行(Execution)"

#: ../../execution.rst:5
msgid "Queries"
msgstr "查询(Queries)"

#: ../../execution.rst:7
msgid ""
"To execute a query against a schema, build a new ``GraphQL`` object with "
"the appropriate arguments and then call ``execute()``."
msgstr "为了对 一个Schema  执行查询。需要先构造一个 ``GraphQL`` 对象，并带着一些参数去调用 ``execute()`` 方法."

#: ../../execution.rst:10
msgid ""
"The result of a query is an ``ExecutionResult`` which is the query data "
"and/or a list of errors."
msgstr "查询将返回一个 ``ExecutionResult`` 对象，其中包含查询的结果数据 （或出错时的错误信息集合）."

#: ../../execution.rst:30
msgid ""
"More complex query examples can be found in the `StarWars query tests "
"<https://github.com/graphql-java/graphql-"
"java/blob/master/src/test/groovy/graphql/StarWarsQueryTest.groovy>`_"
msgstr "更复杂的示例，可以看 `StarWars 查询测试用例 <https://github.com/graphql-java/graphql-java/blob/master/src/test/groovy/graphql/StarWarsQueryTest.groovy>`_"

#: ../../execution.rst:34
msgid "Data Fetchers"
msgstr ""

#: ../../execution.rst:36
msgid ""
"Each graphql field type has a ``graphql.schema.DataFetcher`` associated "
"with it.  Other graphql implementations often call this type of code "
"*resolvers**."
msgstr "每个graphql schema 中的field，都需要绑定相应的 ``graphql.schema.DataFetcher`` 以获取数据.  其它GraphQL的实现把这叫 *resolvers**."

#: ../../execution.rst:39
msgid ""
"Often you can rely on ``graphql.schema.PropertyDataFetcher`` to examine "
"Java POJO objects to provide field values from them.  If your don't "
"specify a data fetcher on a field, this is what will be used."
msgstr "很多时候，你可以用默认的 ``graphql.schema.PropertyDataFetcher`` 去从 Java POJO 中自动提取数据到对应的 field.  如果你未为 field 指定 data fetcher 那么就默认使用它."

#: ../../execution.rst:42
msgid ""
"However you will need to fetch your top level domain objects via your own"
" custom data fetchers.  This might involve making a database call or "
"contacting another system over HTTP say."
msgstr "但你最少需要为顶层的领域对象(domain objects) 编写 data fetchers.  其中可以会与database交互，或用HTTP与其它系统交互."

#: ../../execution.rst:45
msgid ""
"``graphql-java`` is not opinionated about how you get your domain data "
"objects, that is very much your concern.  It is also not opinionated on "
"user authorisation to that data.  You should push all that logic into "
"your business logic layer code."
msgstr "``graphql-java`` 不关心你如何获取你的业务数据，这是你的自己.  它也不关心你如果授权你的业务数据.  你应该在自己的业务逻辑层，去实现这些逻辑."

#: ../../execution.rst:48
msgid "A data fetcher might look like this:"
msgstr "简单 Data fetcher 示例:"

#: ../../execution.rst:59
msgid ""
"Each ``DataFetcher`` is passed a "
"``graphql.schema.DataFetchingEnvironment`` object which contains what "
"field is being fetched, what arguments have been supplied to the field "
"and other information such as the field's parent object, the query root "
"object or the query context object."
msgstr "框架在执行查询时。会调用上面的方法，其中的 ``graphql.schema.DataFetchingEnvironment`` 参数包括以下信息：被查询的 field、查询这个field时可能带上的查询参数、这个field的父数据对象(Source Object)、 查询的ROOT数据对象、查询执行上下文环境对象(query context object)."

#: ../../execution.rst:63
msgid ""
"In the above example, the execution will wait for the data fetcher to "
"return before moving on.  You can make execution of the ``DataFetcher`` "
"asynchronous by returning a ``CompletionStage`` to data, that is "
"explained more further down this page."
msgstr "上面是同步获取数据的例子，执行引擎需要等待一个 data fetcher 返回数据才能继续下一个.  也可以通过编写异步的 ``DataFetcher`` ，异步地返回 ``CompletionStage`` 对象，在下文中将会说明使用方法."

#: ../../execution.rst:67
msgid "Exceptions while fetching data"
msgstr "当获取数据出现异常时"

#: ../../execution.rst:69
msgid ""
"If an exception happens during the data fetcher call, then the execution "
"strategy by default will make a ``graphql.ExceptionWhileDataFetching`` "
"error and add it to the list of errors on the result.  Remember graphql "
"allows partial results with errors."
msgstr "如果异步是出现在调用 data fetcher 时, 默认的执行策略(execution strategy) 将生成一个 ``graphql.ExceptionWhileDataFetching`` 错误，并将其加入到查询结果的错误列表中.  请留意，GraphQL 在发生异常时，允许返回部分成功的数据，并将带上异常信息."

#: ../../execution.rst:73
msgid "Here is the code for the standard behaviour."
msgstr "下面是默认的异常行为处理逻辑."

#: ../../execution.rst:92
msgid ""
"If the exception you throw is itself a `GraphqlError` then it will "
"transfer the message and custom extensions attributes from that exception"
" into the `ExceptionWhileDataFetching` object.  This allows you to place "
"your own custom attributes into the graphql error that is sent back to "
"the caller."
msgstr "如果你抛出的异常本身是  `GraphqlError` 类型，框架会把其中的消息 和 自定义扩展属性（custom extensions attributes）转换到 `ExceptionWhileDataFetching` 对象中.  这可以方便你把自己的错误信息，放到返回给调用者的 GraphQL 错误列表中."

#: ../../execution.rst:96
msgid ""
"For example imagine your data fetcher threw this exception.  The `foo` "
"and `fizz` attributes would be included in the resultant graphql error."
msgstr "例如，你在 DataFetcher 中抛出了这个异常.  那么 `foo` and `fizz` 属性将会包含在返回给调用者的graphql查询错误中."

#: ../../execution.rst:122
msgid ""
"You can change this behaviour by creating your own "
"``graphql.execution.DataFetcherExceptionHandler`` exception handling code"
" and giving that to the execution strategy."
msgstr "你可以编写自己的 ``graphql.execution.DataFetcherExceptionHandler`` 来改变这些逻辑。只需要在执行策略（execution strategy）注册一下."

#: ../../execution.rst:125
msgid ""
"For example the code above records the underlying exception and stack "
"trace.  Some people may prefer not to see that in the output error list."
"  So you can use this mechanism to change that behaviour."
msgstr "例如，上面的代码记录了底层的异常和堆栈.  如果你不希望这些出现在输出的错误列表中。你可以用以下的方法去实现."

#: ../../execution.rst:141
msgid "Serializing results to JSON"
msgstr "序列化成 JSON"

#: ../../execution.rst:143
msgid ""
"The most common way to call graphql is over HTTP and to expect a JSON "
"response back.  So you need to turn an `graphql.ExecutionResult` into a "
"JSON payload."
msgstr "通常，用 HTTP 方法去调用 graphql ，用 JSON 格式作为返回结果.  返回，需要把 `graphql.ExecutionResult` 对象转换为 JSON 格式包."

#: ../../execution.rst:146
msgid ""
"A common way to do that is use a JSON serialisation library like Jackson "
"or GSON.  However exactly how they interpret the data result is "
"particular to them.  For example `nulls` are important in graphql results"
" and hence you must set up the json mappers to include them."
msgstr "一般用 Jackson or GSON 去做 JSON 序列化.  但他们对结果数据的转换方法有一些不同点.  例如 JSON 的`nulls` 在 graphql 结果中的是有用的。所以必须在 json mappers 中设置需要它"

#: ../../execution.rst:150
msgid ""
"To ensure you get a JSON result that confirms 100% to the graphql spec, "
"you should call `toSpecification` on the result and then send that back "
"as JSON."
msgstr "为保证你返回的 JSON 结果 100% 合符 graphql 规范, 应该调用result对象的 `toSpecification` 方法，然后以 JSON格式 发送响应."

#: ../../execution.rst:153
msgid ""
"This will ensure that the result follows the specification outlined in "
"http://facebook.github.io/graphql/#sec-Response"
msgstr "这样就可以确保返回数据合符在 http://facebook.github.io/graphql/#sec-Response 中的规范"

#: ../../execution.rst:167
msgid "Mutations"
msgstr "更新（Mutations）"

#: ../../execution.rst:169
msgid ""
"A good starting point to learn more about mutating data in graphql is "
"`http://graphql.org/learn/queries/#mutations "
"<http://graphql.org/learn/queries/#mutations>`_."
msgstr "如果你不了解什么叫更新（Mutations），建议先阅读规范 `http://graphql.org/learn/queries/#mutations <http://graphql.org/learn/queries/#mutations>`_."

#: ../../execution.rst:171
msgid ""
"In essence you need to define a ``GraphQLObjectType`` that takes "
"arguments as input.  Those arguments are what you can use to mutate your "
"data store via the data fetcher invoked."
msgstr "首先，你需要定义一个支持输入参数的 ``GraphQLObjectType`` .  在更新数据时，框架会带上这些参数去调用 data fetcher."

#: ../../execution.rst:174
msgid "The mutation is invoked via a query like :"
msgstr "下面是，GraphQL 更新语句的例子 :"

#: ../../execution.rst:185
msgid ""
"You need to send in arguments during that mutation operation, in this "
"case for the variables for ``$ep`` and ``$review``"
msgstr "修改操作是需要带输入参数的，上例中对应变量 ``$ep`` and ``$review``"

#: ../../execution.rst:187
msgid "You would create types like this to handle this mutation :"
msgstr "对应地，Schema 应该这么写【译注：以下是 Java 写法，你也可以用SDL写法】 :"

#: ../../execution.rst:241
msgid ""
"Notice that the input arguments are of type ``GraphQLInputObjectType``.  "
"This is important.  Input arguments can ONLY be of that type and you "
"cannot use output types such as ``GraphQLObjectType``.  Scalars types are"
" consider both input and output types."
msgstr "注意，输入参数应该是 ``GraphQLInputObjectType`` 类型.  请留意.  对于修改操作，输入参数只能用这个类型(type)，而不能用如 ``GraphQLObjectType``之类的输出类型(type).  Scalars 类型(type) 可以用于输入和输出."

#: ../../execution.rst:244
msgid ""
"The data fetcher here is responsible for executing the mutation and "
"returning some sensible output values."
msgstr "对于更新操作，DataFetcher的职责是执行数据更新行返回执行结果."

#: ../../execution.rst:277
msgid ""
"Notice how it calls a data store to mutate the backing database and then "
"returns a ``Review`` object that can be used as the output values to the "
"caller."
msgstr "上面代码，先更新业务数据，然后返回 ``Review`` 对象给调用方."

#: ../../execution.rst:281
msgid "Asynchronous Execution"
msgstr "异步执行（Asynchronous Execution）"

#: ../../execution.rst:283
msgid ""
"graphql-java uses fully asynchronous execution techniques when it "
"executes queries.  You can get the ``CompleteableFuture`` to results by "
"calling ``executeAsync()`` like this"
msgstr "graphql-java 是个全异步的执行引擎.  如下，调用 ``executeAsync()`` 后，返回  ``CompleteableFuture`` ："

#: ../../execution.rst:302
msgid ""
"The use of ``CompletableFuture`` allows you to compose actions and "
"functions that will be applied when the execution completes.  The final "
"call to ``.join()`` waits for the execution to happen."
msgstr "使用 ``CompletableFuture`` 对象，你可以指定，在查询完成后，组合其它操作(action)或函数你的函数.  需要你需要同步等待执行结果 ，可以调用 ``.join()`` 方法."

#: ../../execution.rst:305
msgid ""
"In fact under the covers, the graphql-java engine uses asynchronous "
"execution and makes the ``.execute()`` method appear synchronous by "
"calling join for you.  So the following code is in fact the same."
msgstr "graphql-java引擎内部是异步执行的，但你可以通过调用 join 方法变为同步等待.  下面是等效的代码："

#: ../../execution.rst:319
msgid ""
"If a ``graphql.schema.DataFetcher`` returns a ``CompletableFuture<T>`` "
"object then this will be composed into the overall asynchronous query "
"execution.  This means you can fire off a number of field fetching "
"requests in parallel.  Exactly what threading strategy you use is up to "
"your data fetcher code."
msgstr "如果你编写的 ``graphql.schema.DataFetcher`` 返回 ``CompletableFuture<T>`` 对象，那么它会被糅合到整个异步查询中.  这样，你可以同时发起我个数据获取操作，让它们并行运行.  而由DataFetcher控制具体的线程并发策略."

#: ../../execution.rst:323
msgid ""
"The following code uses the standard Java "
"``java.util.concurrent.ForkJoinPool.commonPool()`` thread executor to "
"supply values in another thread."
msgstr "下面示例使用 ``java.util.concurrent.ForkJoinPool.commonPool()`` 并行执行器，用其它线程完成数据获取."

#: ../../execution.rst:338
msgid ""
"The code above is written in long form.  With Java 8 lambdas it can be "
"written more succinctly as follows"
msgstr "上面是旧的写法，也可以用Java 8 lambdas 的写法："

#: ../../execution.rst:345
msgid ""
"The graphql-java engine ensures that all the ``CompletableFuture`` "
"objects are composed together to provide an execution result that follows"
" the graphql specification."
msgstr "graphql-java 保证所有 ``CompletableFuture`` 对象组合，最后生成合符 graphql 规范的执行结果."

#: ../../execution.rst:348
msgid ""
"There is a helpful shortcut in graphql-java to create asynchronous data "
"fetchers. Use ``graphql.schema.AsyncDataFetcher.async(DataFetcher<T>)`` "
"to wrap a ``DataFetcher``. This can be used with static imports to "
"produce more readable code."
msgstr "还有一个方法可以简化异步 data fetchers 的编写. 使用 ``graphql.schema.AsyncDataFetcher.async(DataFetcher<T>)`` 去包装``DataFetcher``. 这样可以使用 static imports 来提高代码可读性."

#: ../../execution.rst:357
msgid "Execution Strategies"
msgstr "关于执行策略（Execution Strategies）"

#: ../../execution.rst:359
msgid ""
"A class derived from ``graphql.execution.ExecutionStrategy`` is used to "
"run a query or mutation.  A number of different strategies are provided "
"with graphql-java and if you are really keen you can even write your own."
msgstr "在执行查询或更新数据时，引擎会使用实现了 ``graphql.execution.ExecutionStrategy``接口 的对象，来决定执行策略.  graphql-java 中已经有几个现成的策略，但如果你需要，你可以写自己的。."

#: ../../execution.rst:362
msgid ""
"You can wire in what execution strategy to use when you create the "
"``GraphQL`` object."
msgstr "你可以这样给 ``GraphQL`` 对象绑定执行策略。"

#: ../../execution.rst:372
msgid ""
"In fact the code above is equivalent to the default settings and is a "
"very sensible choice of execution strategies for most cases."
msgstr "实际上，上面就是引擎默认的策略了。大部分情况下用它就够了。"

#: ../../execution.rst:376
msgid "AsyncExecutionStrategy"
msgstr "异步执行策略（AsyncExecutionStrategy）"

#: ../../execution.rst:378
msgid ""
"By default the \"query\" execution strategy is "
"``graphql.execution.AsyncExecutionStrategy`` which will dispatch each "
"field as ``CompleteableFuture`` objects and not care which ones complete "
"first.  This strategy allows for the most performant execution."
msgstr "默认的查询 执行策略是 ``graphql.execution.AsyncExecutionStrategy`` ，它会把每个 field 返回视为 ``CompleteableFuture`` 。它并不会控制 filed 的获取顺序.  这个策略可以优化查询执行的性能."

#: ../../execution.rst:382
msgid ""
"The data fetchers invoked can themselves return `CompletionStage`` values"
" and this will create fully asynchronous behaviour."
msgstr "Data fetchers 返回 `CompletionStage`` 对象，就可以全异步执行整个查询了。"

#: ../../execution.rst:385
msgid "So imagine a query as follows"
msgstr "例如以下的查询："

#: ../../execution.rst:401
msgid ""
"The ``AsyncExecutionStrategy`` is free to dispatch the *enemies* field at"
" the same time as the *friends* field.  It does not have to do *enemies* "
"first followed by *friends*, which would be less efficient."
msgstr " ``AsyncExecutionStrategy`` 策略可能会同时发起获取 *enemies* field 和 *friends* field 的操作。.  而不需要先发获取 *enemies* 再获取 *friends*，那样效率更低。"

#: ../../execution.rst:404
msgid ""
"It will however assemble the results in order.  The query result will "
"follow the graphql specification and return object values assembled in "
"query field order.  Only the execution of data fetching is free to be in "
"any order."
msgstr "这个策略不会按顺序来集成结果数据。但查询结果会按GraphQL规范顺序来返回。只是数据获取的顺序不确定。"

#: ../../execution.rst:407
msgid ""
"This behaviour is allowed in the graphql specification and in fact is "
"actively encouraged http://facebook.github.io/graphql/#sec-Query for read"
" only queries."
msgstr "对于查询，这个策略是 graphql 规范 http://facebook.github.io/graphql/#sec-Query 允许和推荐的。"

#: ../../execution.rst:410
msgid ""
"See `specification <http://facebook.github.io/graphql/#sec-Normal-"
"evaluation>`_ for details."
msgstr "详细见 `规范 <http://facebook.github.io/graphql/#sec-Normal-evaluation>`_ ."

#: ../../execution.rst:414
msgid "AsyncSerialExecutionStrategy"
msgstr "异步顺序执行策略（AsyncSerialExecutionStrategy）"

#: ../../execution.rst:416
msgid ""
"The graphql specification says that mutations MUST be executed serially "
"and in the order in which the query fields occur."
msgstr "Graphql 规范指出，修改操作（mutations）“必须”按照 field 的顺序来执行。"

#: ../../execution.rst:419
msgid ""
"So ``graphql.execution.AsyncSerialExecutionStrategy`` is used by default "
"for mutations and will ensure that each field is completed before it "
"processes the next one and so forth.  You can still return "
"``CompletionStage`` objects in the mutation data fetchers, however they "
"will be executed serially and will be completed before the next mutation "
"field data fetcher is dispatched."
msgstr "所以，为了确保一个 field 一个 field 顺序地执行更新，更新操作（mutations）默认使用 ``graphql.execution.AsyncSerialExecutionStrategy`` 策略。你的 mutation Data Fetcher 仍然可以返回 ``CompletionStage`` 对象, 但它和其它 field 的是串行执行的。  "

#: ../../execution.rst:425
msgid "ExecutorServiceExecutionStrategy"
msgstr "基于执行器的执行策略：ExecutorServiceExecutionStrategy "

#: ../../execution.rst:427
msgid ""
"The ``graphql.execution.ExecutorServiceExecutionStrategy`` execution "
"strategy will always dispatch each field fetch in an asynchronous manner,"
" using the executor you give it.  It differs from "
"``AsyncExecutionStrategy`` in that it does not rely on the data fetchers "
"to be asynchronous but rather makes the field fetch invocation "
"asynchronous by submitting each field to the provided "
"`java.util.concurrent.ExecutorService`."
msgstr " ``graphql.execution.ExecutorServiceExecutionStrategy`` 执行策略，使用了指定的执行器（executor），来异步地执行数据获取任务。它与 ``AsyncExecutionStrategy`` 执行策略不同，它不依赖 data fetchers 去异步执行获取任务，它依赖于输入的 `java.util.concurrent.ExecutorService` 。"

#: ../../execution.rst:432
msgid ""
"This behaviour makes it unsuitable to be used as a mutation execution "
"strategy."
msgstr "因为这样，所以它不能用于更新(mutation)操作。"

#: ../../execution.rst:450
msgid "SubscriptionExecutionStrategy"
msgstr "订阅执行策略（SubscriptionExecutionStrategy）"

#: ../../execution.rst:452
msgid ""
"Graphql subscriptions allows you to create stateful subscriptions to "
"graphql data.  You uses ``SubscriptionExecutionStrategy`` as your "
"execution strategy as it has the support for the reactive-streams APIs."
msgstr "Graphql 订阅（subscriptions） 使你可以对GraphQL 数据进行为状态的订阅。你可以使用 ``SubscriptionExecutionStrategy`` 执行策略，它支持 reactive-streams APIs。"

#: ../../execution.rst:455
msgid ""
"See http://www.reactive-streams.org/ for more information on the reactive"
" ``Publisher`` and ``Subscriber`` interfaces."
msgstr "阅读 http://www.reactive-streams.org/ 可以得到关于 ``Publisher`` 和 ``Subscriber`` 接口的更多信息。"

#: ../../execution.rst:457
msgid ""
"Also see the page on subscriptions for more details on how to write a "
"subscription based graphql service."
msgstr "也可以阅读subscriptions的文档，以了解如何编写基于支持订阅的 graphql 服务。"

#: ../../execution.rst:461
msgid "BatchedExecutionStrategy"
msgstr "批量化执行器（BatchedExecutionStrategy）"

#: ../../execution.rst:463
msgid ""
"Alternatively, schemas with nested lists may benefit from using a "
"``graphql.execution.batched.BatchedExecutionStrategy`` and creating "
"batched DataFetchers with get() methods annotated @Batched."
msgstr "对于有数组（list）field 的 schemas， 我们提供了 ``graphql.execution.batched.BatchedExecutionStrategy`` 策略。它可以批量化地调用标注了@Batched 的 DataFetchers 的 get() 方法。"

#: ../../execution.rst:468
msgid ""
"on how BatchedExecutionStrategy works here.  Its a pretty special case "
"that I don't know how to explain properly"
msgstr "关于 BatchedExecutionStrategy 是如何工作的。它是如此的特别，让我不知道如何解释【译注：原文：Its a pretty special case that I don't know how to explain properly】"

#: ../../execution.rst:471
msgid "Limiting Field Visibility"
msgstr "控制字段的可见性"

#: ../../execution.rst:473
msgid ""
"By default every fields defined in a `GraphqlSchema` is available.  There"
" are cases where you may want to restrict certain fields depending on the"
" user."
msgstr "所有  `GraphqlSchema` 的字段（field）默认都是可以访问的。但有时候，你可能想不同用户看到不同部分的字段。"

#: ../../execution.rst:476
msgid ""
"You can do this by using a "
"`graphql.schema.visibility.GraphqlFieldVisibility` implementation and "
"attaching it to the schema."
msgstr "你可以在schema 上绑定一个 `graphql.schema.visibility.GraphqlFieldVisibility` 对象。."

#: ../../execution.rst:478
msgid ""
"A simple `graphql.schema.visibility.BlockedFields` implementation based "
"on fully qualified field name is provided."
msgstr "框架提供了一个可以指定字段(field)名的实现，叫 `graphql.schema.visibility.BlockedFields`.."

#: ../../execution.rst:493
msgid ""
"There is also another implementation that prevents instrumentation from "
"being able to be performed on your schema, if that is a requirement."
msgstr "如果你需要，还有一个实现可以防止 instrumentation 拦截你的 schema。"

#: ../../execution.rst:495
msgid ""
"Note that this puts your server in contravention of the graphql "
"specification and expectations of most clients so use this with caution."
msgstr "请注意，这会使您的服务器违反graphql规范和大多数客户端的预期，因此请谨慎使用."

#: ../../execution.rst:506
msgid ""
"You can create your own derivation of `GraphqlFieldVisibility` to check "
"what ever you need to do to work out what fields should be visible or "
"not."
msgstr "你可以编写自己的 `GraphqlFieldVisibility` 来控制字段的可见性。"

#: ../../execution.rst:542
msgid "Query Caching"
msgstr "查询缓存（Query Caching）"

#: ../../execution.rst:544
msgid ""
"Before the ``graphql-java`` engine executes a query it must be parsed and"
" validated, and this process can be somewhat time consuming."
msgstr " ``graphql-java`` 引擎执行查询前，必须先对查询语句作解释和校验，有时这是比较耗时的。"

#: ../../execution.rst:546
msgid ""
"To avoid the need for re-parse/validate the ``GraphQL.Builder`` allows an"
" instance of ``PreparsedDocumentProvider`` to reuse ``Document`` "
"instances."
msgstr "为了避免重复的解释和校验。 ``GraphQL.Builder`` 可以使用``PreparsedDocumentProvider``去重用 ``Document`` 实例。"

#: ../../execution.rst:548
msgid ""
"Please note that this does not cache the result of the query, only the "
"parsed ``Document``."
msgstr "它不是缓存 查询结果，只是缓存解释过的文档（ ``Document`` ）。"

#: ../../execution.rst:558
msgid ""
"Create an instance of preferred cache instance, here is `Caffeine "
"<https://github.com/ben-manes/caffeine>`_  used as it is a high quality "
"caching solution. The cache instance should be thread safe and shared."
msgstr "创建你需要的缓存实例，本例子是使用的是 `Caffeine <https://github.com/ben-manes/caffeine>`_  。它是个高质量的缓存解决方案。缓存实例应该是线程安全和可以线程间共享的。"

#: ../../execution.rst:559
msgid ""
"The ``PreparsedDocumentProvider`` is a functional interface with only a "
"get method and we can therefore pass a method reference that matches the "
"signature into the builder."
msgstr "``PreparsedDocumentProvider`` 是一个函式接口（ functional interface），方法名是get。."

#: ../../execution.rst:562
msgid ""
"In order to achieve high cache hit ration it is recommended that field "
"arguments are passed in as variables instead of directly in the query."
msgstr "为提高缓存命中率，GraphQL 语句中的 field 参数（arguments）建议使用变量（ variables）来表达，而不是直接把值写在语句中。"

#: ../../execution.rst:564
msgid "The following query:"
msgstr "下面的查询 ："

#: ../../execution.rst:574
msgid "Should be rewritten as:"
msgstr "应该写成："

#: ../../execution.rst:584
msgid "with variables:"
msgstr "带上参数（ variables）："

#: ../../execution.rst:592
msgid "The query is now reused regardless of variable values provided."
msgstr "这样，这不管查询的变量（variable）如何变化 ，查询解释也就可以重用。"

